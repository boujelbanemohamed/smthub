================================================================================
                    GUIDE COMPLET DE MIGRATION SMT HUB
                    RedHat + PostgreSQL + Production
================================================================================

📋 PRÉREQUIS SYSTÈME
================================================================================

Système d'exploitation requis :
- RedHat Enterprise Linux 8/9 ou CentOS 8/9
- Mémoire minimale : 4GB RAM
- Espace disque : 20GB minimum
- CPU : 2 cœurs minimum

Services requis :
- Node.js 18+ (LTS recommandé)
- Nginx (reverse proxy)
- PM2 (process manager)
- PostgreSQL 13+
- Firewall (firewalld)
- SELinux (configuré)

================================================================================
ÉTAPE 1 : PRÉPARATION DU SERVEUR REDHAT
================================================================================

1.1 Mise à jour du système
```bash
# Mise à jour du système
sudo dnf update -y

# Installation des outils de base
sudo dnf install -y wget curl git unzip vim htop
```

1.2 Installation de Node.js
```bash
# Ajout du repository NodeSource
curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash -

# Installation de Node.js
sudo dnf install -y nodejs

# Vérification
node --version
npm --version
```

1.3 Installation de Nginx
```bash
# Installation de Nginx
sudo dnf install -y nginx

# Démarrage et activation
sudo systemctl start nginx
sudo systemctl enable nginx
```

1.4 Installation de PM2
```bash
# Installation globale de PM2
sudo npm install -g pm2

# Configuration PM2 pour démarrer au boot
pm2 startup
```

================================================================================
ÉTAPE 2 : INSTALLATION ET CONFIGURATION POSTGRESQL
================================================================================

2.1 Installation PostgreSQL
```bash
# Installation PostgreSQL
sudo dnf install -y postgresql postgresql-server postgresql-contrib

# Initialisation de la base de données
sudo postgresql-setup --initdb

# Démarrage et activation
sudo systemctl enable postgresql
sudo systemctl start postgresql

# Vérification du statut
sudo systemctl status postgresql
```

2.2 Configuration PostgreSQL
```bash
# Accéder à PostgreSQL en tant qu'utilisateur postgres
sudo -u postgres psql

# Créer l'utilisateur et la base de données pour SMT HUB
CREATE USER smt_user WITH PASSWORD 'smt_password_2024';
CREATE DATABASE smt_hub OWNER smt_user;
GRANT ALL PRIVILEGES ON DATABASE smt_hub TO smt_user;
\q
```

2.3 Configuration de sécurité PostgreSQL
```bash
# Éditer la configuration PostgreSQL
sudo vim /var/lib/pgsql/data/postgresql.conf

# Ajouter/modifier ces lignes :
listen_addresses = 'localhost'
port = 5432
max_connections = 100
shared_buffers = 128MB
effective_cache_size = 512MB

# Éditer la configuration d'authentification
sudo vim /var/lib/pgsql/data/pg_hba.conf

# Ajouter cette ligne pour l'authentification locale :
local   smt_hub    smt_user    md5

# Redémarrer PostgreSQL
sudo systemctl restart postgresql
```

================================================================================
ÉTAPE 3 : INSTALLATION DE PRISMA ET CONFIGURATION
================================================================================

3.1 Préparation de l'application
```bash
# Créer le répertoire d'application
sudo mkdir -p /var/www/smt-hub
sudo chown $USER:$USER /var/www/smt-hub

# Copier l'application
cp -r * /var/www/smt-hub/

# Aller dans le répertoire
cd /var/www/smt-hub
```

3.2 Installation de Prisma
```bash
# Installation de Prisma
npm install prisma @prisma/client

# Initialisation de Prisma
npx prisma init
```

3.3 Configuration du schéma Prisma
```bash
# Créer le fichier prisma/schema.prisma
cat > prisma/schema.prisma << 'EOF'
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  nom       String
  email     String   @unique
  role      String   @default("utilisateur")
  mot_de_passe String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userAccess UserAccess[]
}

model Application {
  id              Int      @id @default(autoincrement())
  nom             String
  image_url       String
  app_url         String
  ordre_affichage Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  userAccess UserAccess[]
}

model UserAccess {
  id             Int    @id @default(autoincrement())
  utilisateur_id Int
  application_id Int
  createdAt      DateTime @default(now())

  user        User        @relation(fields: [utilisateur_id], references: [id], onDelete: Cascade)
  application Application @relation(fields: [application_id], references: [id], onDelete: Cascade)

  @@unique([utilisateur_id, application_id])
}

model EmailTemplate {
  id          String   @id @default(cuid())
  name        String
  subject     String
  content     String
  category    String
  enabled     Boolean  @default(true)
  variables   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model AdminLog {
  id        Int      @id @default(autoincrement())
  level     String
  action    String
  message   String
  details   String?
  status    String   @default("SUCCESS")
  createdAt DateTime @default(now())
}

model SmtpConfig {
  id         Int      @id @default(autoincrement())
  host       String
  port       Int
  user       String
  password   String
  from_name  String
  from_email String
  secure     Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}
EOF
```

3.4 Configuration des variables d'environnement
```bash
# Créer le fichier .env.production
cat > .env.production << 'EOF'
# Configuration de base
NODE_ENV=production
PORT=4000

# Configuration PostgreSQL
DATABASE_URL=postgresql://smt_user:smt_password_2024@localhost:5432/smt_hub

# Configuration SMTP (optionnel)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password
SMTP_FROM=noreply@smt.com

# Configuration de sécurité
JWT_SECRET=your_super_secret_jwt_key_here_change_this_in_production
COOKIE_SECRET=your_super_secret_cookie_key_here_change_this_in_production

# Configuration des logs
LOG_LEVEL=INFO
LOG_RETENTION_DAYS=30

# Configuration du cache
CACHE_TTL=300
CACHE_MAX_SIZE=1000

# Configuration de l'application
NEXT_PUBLIC_APP_URL=https://your-domain.com
NEXT_PUBLIC_API_URL=https://your-domain.com/api

# Configuration des performances
NEXT_PUBLIC_ENABLE_CACHE=true
NEXT_PUBLIC_ENABLE_LOGGING=true
EOF
```

3.5 Génération du client Prisma et création de la base de données
```bash
# Générer le client Prisma
npx prisma generate

# Créer les tables dans la base de données
npx prisma db push

# Vérifier la structure
npx prisma studio
```

================================================================================
ÉTAPE 4 : SCRIPT DE MIGRATION DES DONNÉES JSON VERS POSTGRESQL
================================================================================

4.1 Créer le script de migration
```bash
# Créer le répertoire scripts
mkdir -p scripts

# Créer le script de migration
cat > scripts/migrate-to-postgresql.ts << 'EOF'
import { PrismaClient } from '@prisma/client'
import fs from 'fs'
import path from 'path'

const prisma = new PrismaClient()

async function migrateData() {
  try {
    console.log('🚀 Début de la migration des données vers PostgreSQL...')

    const dataPath = path.join(process.cwd(), 'data')
    
    // Migration des utilisateurs
    if (fs.existsSync(path.join(dataPath, 'users.json'))) {
      const users = JSON.parse(fs.readFileSync(path.join(dataPath, 'users.json'), 'utf8'))
      console.log(`📊 Migration de ${users.length} utilisateurs...`)
      
      for (const user of users) {
        await prisma.user.upsert({
          where: { id: user.id },
          update: {
            nom: user.nom,
            email: user.email,
            role: user.role,
            mot_de_passe: user.mot_de_passe
          },
          create: {
            id: user.id,
            nom: user.nom,
            email: user.email,
            role: user.role,
            mot_de_passe: user.mot_de_passe
          }
        })
      }
    }

    // Migration des applications
    if (fs.existsSync(path.join(dataPath, 'applications.json'))) {
      const applications = JSON.parse(fs.readFileSync(path.join(dataPath, 'applications.json'), 'utf8'))
      console.log(`📊 Migration de ${applications.length} applications...`)
      
      for (const app of applications) {
        await prisma.application.upsert({
          where: { id: app.id },
          update: {
            nom: app.nom,
            image_url: app.image_url,
            app_url: app.app_url,
            ordre_affichage: app.ordre_affichage
          },
          create: {
            id: app.id,
            nom: app.nom,
            image_url: app.image_url,
            app_url: app.app_url,
            ordre_affichage: app.ordre_affichage
          }
        })
      }
    }

    // Migration des accès utilisateurs
    if (fs.existsSync(path.join(dataPath, 'user_access.json'))) {
      const userAccess = JSON.parse(fs.readFileSync(path.join(dataPath, 'user_access.json'), 'utf8'))
      console.log(`📊 Migration de ${userAccess.length} accès utilisateurs...`)
      
      for (const access of userAccess) {
        await prisma.userAccess.upsert({
          where: {
            utilisateur_id_application_id: {
              utilisateur_id: access.utilisateur_id,
              application_id: access.application_id
            }
          },
          update: {},
          create: {
            utilisateur_id: access.utilisateur_id,
            application_id: access.application_id
          }
        })
      }
    }

    // Migration des templates d'emails
    if (fs.existsSync(path.join(dataPath, 'email-templates.json'))) {
      const emailTemplates = JSON.parse(fs.readFileSync(path.join(dataPath, 'email-templates.json'), 'utf8'))
      console.log(`📊 Migration des templates d'emails...`)
      
      for (const template of emailTemplates.templates) {
        await prisma.emailTemplate.upsert({
          where: { id: template.id },
          update: {
            name: template.name,
            subject: template.subject,
            content: template.content,
            category: template.category,
            enabled: template.enabled,
            variables: JSON.stringify(template.variables)
          },
          create: {
            id: template.id,
            name: template.name,
            subject: template.subject,
            content: template.content,
            category: template.category,
            enabled: template.enabled,
            variables: JSON.stringify(template.variables)
          }
        })
      }
    }

    // Migration des logs
    if (fs.existsSync(path.join(dataPath, 'admin-logs.json'))) {
      const logs = JSON.parse(fs.readFileSync(path.join(dataPath, 'admin-logs.json'), 'utf8'))
      console.log(`📊 Migration de ${logs.length} logs...`)
      
      for (const log of logs) {
        await prisma.adminLog.create({
          data: {
            level: log.level,
            action: log.action,
            message: log.message,
            details: log.details ? JSON.stringify(log.details) : null,
            status: log.status,
            createdAt: new Date(log.timestamp)
          }
        })
      }
    }

    console.log('✅ Migration terminée avec succès!')
  } catch (error) {
    console.error('❌ Erreur lors de la migration:', error)
    throw error
  } finally {
    await prisma.$disconnect()
  }
}

migrateData()
EOF
```

4.2 Exécuter la migration
```bash
# Installer ts-node si nécessaire
npm install -g ts-node

# Exécuter la migration
npx ts-node scripts/migrate-to-postgresql.ts

# Vérifier les données migrées
npx prisma studio
```

================================================================================
ÉTAPE 5 : CONFIGURATION NGINX
================================================================================

5.1 Configuration du site
```bash
# Créer la configuration Nginx
sudo tee /etc/nginx/sites-available/smt-hub << 'EOF'
server {
    listen 80;
    server_name your-domain.com www.your-domain.com;

    # Redirection HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com www.your-domain.com;

    # Configuration SSL (à adapter selon votre certificat)
    ssl_certificate /etc/ssl/certs/your-domain.crt;
    ssl_certificate_key /etc/ssl/private/your-domain.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Headers de sécurité
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Configuration des logs
    access_log /var/log/nginx/smt-hub.access.log;
    error_log /var/log/nginx/smt-hub.error.log;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied expired no-cache no-store private must-revalidate auth;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/javascript application/json;

    # Proxy vers l'application Next.js
    location / {
        proxy_pass http://127.0.0.1:4000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 86400;
        proxy_connect_timeout 60;
        proxy_send_timeout 60;
    }

    # Cache statique Next.js
    location /_next/static/ {
        alias /var/www/smt-hub/.next/static/;
        expires 365d;
        access_log off;
        add_header Cache-Control "public, immutable";
    }

    # Cache public
    location /public/ {
        alias /var/www/smt-hub/public/;
        expires 30d;
        access_log off;
        add_header Cache-Control "public";
    }

    # Cache des images
    location ~* \.(jpg|jpeg|png|gif|ico|svg|webp)$ {
        expires 30d;
        add_header Cache-Control "public";
        access_log off;
    }

    # Cache des assets CSS/JS
    location ~* \.(css|js)$ {
        expires 7d;
        add_header Cache-Control "public";
        access_log off;
    }

    # Sécurité - Bloquer l'accès aux fichiers sensibles
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    location ~ \.(env|log|sql|conf|ini|bak|swp|tmp)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;

    location /api/auth/login {
        limit_req zone=login burst=5 nodelay;
        proxy_pass http://127.0.0.1:4000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://127.0.0.1:4000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
EOF
```

5.2 Activation du site
```bash
# Créer le lien symbolique
sudo ln -s /etc/nginx/sites-available/smt-hub /etc/nginx/sites-enabled/

# Tester la configuration
sudo nginx -t

# Redémarrer Nginx
sudo systemctl restart nginx
```

================================================================================
ÉTAPE 6 : CONFIGURATION SÉCURITÉ
================================================================================

6.1 Configuration Firewall
```bash
# Configuration du firewall
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --permanent --add-port=4000/tcp
sudo firewall-cmd --permanent --add-service=postgresql
sudo firewall-cmd --reload
```

6.2 Configuration SELinux
```bash
# Configuration SELinux pour Nginx
sudo setsebool -P httpd_can_network_connect 1

# Configuration pour l'application
sudo semanage port -a -t http_port_t -p tcp 4000

# Configuration pour PostgreSQL
sudo setsebool -P postgresql_can_network_connect 1
```

6.3 Configuration des permissions
```bash
# Permissions pour l'application
sudo chown -R nginx:nginx /var/www/smt-hub
sudo chmod -R 755 /var/www/smt-hub

# Permissions pour les logs
sudo chown -R nginx:nginx /var/log/smt-hub
```

================================================================================
ÉTAPE 7 : CONFIGURATION PM2 ET DÉMARRAGE
================================================================================

7.1 Configuration PM2
```bash
# Créer le fichier ecosystem.config.js
cat > ecosystem.config.js << 'EOF'
module.exports = {
  apps: [
    {
      name: 'smt-hub',
      script: 'node_modules/next/dist/bin/next',
      args: 'start',
      cwd: '/var/www/smt-hub',
      instances: 'max',
      exec_mode: 'cluster',
      env: {
        NODE_ENV: 'production',
        PORT: 4000,
      },
      env_file: '.env.production',
      error_file: '/var/log/smt-hub/error.log',
      out_file: '/var/log/smt-hub/out.log',
      log_file: '/var/log/smt-hub/combined.log',
      time: true,
      max_memory_restart: '1G',
      restart_delay: 4000,
      max_restarts: 10,
      min_uptime: '10s',
      pmx: true,
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      node_args: '--max-old-space-size=1024',
    },
  ],
}
EOF
```

7.2 Création des logs et démarrage
```bash
# Créer le répertoire de logs
sudo mkdir -p /var/log/smt-hub
sudo chown $USER:$USER /var/log/smt-hub

# Installation des dépendances
npm ci --only=production

# Build de l'application
npm run build

# Démarrer l'application
pm2 start ecosystem.config.js

# Sauvegarder la configuration PM2
pm2 save
```

================================================================================
ÉTAPE 8 : CONFIGURATION SSL (LET'S ENCRYPT)
================================================================================

8.1 Installation de Certbot
```bash
# Installation de Certbot
sudo dnf install -y certbot python3-certbot-nginx

# Obtenir un certificat SSL
sudo certbot --nginx -d your-domain.com

# Configuration du renouvellement automatique
sudo crontab -e

# Ajouter cette ligne pour le renouvellement automatique :
0 12 * * * /usr/bin/certbot renew --quiet
```

================================================================================
ÉTAPE 9 : MONITORING ET MAINTENANCE
================================================================================

9.1 Configuration des logs
```bash
# Rotation des logs
sudo tee /etc/logrotate.d/smt-hub << 'EOF'
/var/log/smt-hub/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 644 nginx nginx
    postrotate
        pm2 reloadLogs
    endscript
}
EOF
```

9.2 Monitoring PM2
```bash
# Installation de PM2 monitoring
pm2 install pm2-server-monit

# Configuration du monitoring
pm2 set pm2-server-monit:email your-email@domain.com

# Installation de PM2 logrotate
pm2 install pm2-logrotate
pm2 set pm2-logrotate:max_size 10M
pm2 set pm2-logrotate:retain 30
```

9.3 Script de maintenance
```bash
# Créer le script de maintenance
cat > maintenance.sh << 'EOF'
#!/bin/bash

# Script de maintenance SMT HUB
echo "🔧 Maintenance SMT HUB..."

# Sauvegarde de la base de données
pg_dump -h localhost -U smt_user -d smt_hub > /var/backup/smt-hub/db_backup_$(date +%Y%m%d_%H%M%S).sql

# Nettoyage des logs anciens
find /var/log/smt-hub -name "*.log" -mtime +30 -delete

# Redémarrage de l'application
pm2 restart smt-hub

echo "✅ Maintenance terminée!"
EOF

chmod +x maintenance.sh
```

================================================================================
ÉTAPE 10 : VÉRIFICATIONS ET TESTS
================================================================================

10.1 Tests de connectivité
```bash
# Test local
curl -I http://localhost:4000

# Test via Nginx
curl -I https://your-domain.com

# Test de la base de données
psql -h localhost -U smt_user -d smt_hub -c "SELECT COUNT(*) FROM \"User\";"
```

10.2 Tests de performance
```bash
# Test de charge simple
ab -n 1000 -c 10 https://your-domain.com/

# Monitoring des ressources
htop
pm2 monit
```

10.3 Tests de sécurité
```bash
# Vérification des ports ouverts
sudo netstat -tlnp

# Vérification SSL
openssl s_client -connect your-domain.com:443
```

================================================================================
ÉTAPE 11 : SAUVEGARDE ET RÉCUPÉRATION
================================================================================

11.1 Script de sauvegarde
```bash
# Créer le script de sauvegarde
cat > backup.sh << 'EOF'
#!/bin/bash

# Script de sauvegarde SMT HUB
BACKUP_DIR="/var/backup/smt-hub"
DATE=$(date +%Y%m%d_%H%M%S)

# Créer le répertoire de sauvegarde
sudo mkdir -p $BACKUP_DIR

# Sauvegarde de la base de données
pg_dump -h localhost -U smt_user -d smt_hub > $BACKUP_DIR/db_backup_$DATE.sql

# Sauvegarde des fichiers de l'application
tar -czf $BACKUP_DIR/app_backup_$DATE.tar.gz -C /var/www/smt-hub .

# Sauvegarde des logs
tar -czf $BACKUP_DIR/logs_backup_$DATE.tar.gz -C /var/log/smt-hub .

echo "✅ Sauvegarde terminée: $DATE"
EOF

chmod +x backup.sh
```

11.2 Script de restauration
```bash
# Créer le script de restauration
cat > restore.sh << 'EOF'
#!/bin/bash

# Script de restauration SMT HUB
if [ -z "$1" ]; then
    echo "Usage: $0 <backup_date>"
    exit 1
fi

BACKUP_DATE=$1
BACKUP_DIR="/var/backup/smt-hub"

# Restaurer la base de données
psql -h localhost -U smt_user -d smt_hub < $BACKUP_DIR/db_backup_$BACKUP_DATE.sql

# Restaurer les fichiers de l'application
tar -xzf $BACKUP_DIR/app_backup_$BACKUP_DATE.tar.gz -C /var/www/smt-hub

# Redémarrer l'application
pm2 restart smt-hub

echo "✅ Restauration terminée pour la date: $BACKUP_DATE"
EOF

chmod +x restore.sh
```

================================================================================
ÉTAPE 12 : AUTOMATISATION ET CRON
================================================================================

12.1 Configuration des tâches cron
```bash
# Éditer le crontab
sudo crontab -e

# Ajouter ces lignes :
# Sauvegarde quotidienne à 2h du matin
0 2 * * * /var/www/smt-hub/backup.sh

# Maintenance quotidienne à 3h du matin
0 3 * * * /var/www/smt-hub/maintenance.sh

# Vérification des logs d'erreur toutes les 6 heures
0 */6 * * * tail -n 100 /var/log/smt-hub/error.log | grep -i error && echo "Erreurs détectées dans les logs SMT HUB" | mail -s "Alerte SMT HUB" admin@domain.com
```

================================================================================
CHECKLIST FINALE
================================================================================

✅ Prérequis système :
- [ ] RedHat/CentOS installé et à jour
- [ ] Node.js 18+ installé
- [ ] Nginx installé et configuré
- [ ] PM2 installé
- [ ] PostgreSQL installé et configuré

✅ Application :
- [ ] Code déployé sur le serveur
- [ ] Variables d'environnement configurées
- [ ] Prisma installé et configuré
- [ ] Base de données créée
- [ ] Données migrées depuis JSON
- [ ] Build de production effectué
- [ ] PM2 configuré et démarré

✅ Infrastructure :
- [ ] Nginx configuré et actif
- [ ] SSL configuré avec Let's Encrypt
- [ ] Firewall ouvert
- [ ] SELinux configuré
- [ ] Monitoring configuré

✅ Tests :
- [ ] Application accessible
- [ ] SSL fonctionnel
- [ ] Base de données connectée
- [ ] Logs générés
- [ ] Performance acceptable
- [ ] Sécurité vérifiée

✅ Maintenance :
- [ ] Sauvegardes automatisées
- [ ] Scripts de maintenance
- [ ] Monitoring configuré
- [ ] Alertes configurées

================================================================================
COMMANDES UTILES POUR LA MAINTENANCE
================================================================================

# Statut de l'application
pm2 status
pm2 logs smt-hub

# Statut des services
sudo systemctl status nginx
sudo systemctl status postgresql

# Logs système
sudo journalctl -u nginx -f
sudo journalctl -u postgresql -f

# Base de données
psql -h localhost -U smt_user -d smt_hub
\dt  # Lister les tables
SELECT COUNT(*) FROM "User";  # Compter les utilisateurs

# Monitoring
htop
pm2 monit
df -h  # Espace disque
free -h  # Mémoire

# Sauvegarde manuelle
./backup.sh

# Restauration manuelle
./restore.sh 20241201_143000

================================================================================
DÉPANNAGE
================================================================================

Problème : Application ne démarre pas
Solution :
```bash
# Vérifier les logs
pm2 logs smt-hub

# Vérifier les variables d'environnement
pm2 env smt-hub

# Vérifier la base de données
psql -h localhost -U smt_user -d smt_hub -c "SELECT 1;"
```

Problème : Nginx ne fonctionne pas
Solution :
```bash
# Vérifier la configuration
sudo nginx -t

# Vérifier les logs
sudo tail -f /var/log/nginx/error.log

# Vérifier le statut
sudo systemctl status nginx
```

Problème : Base de données inaccessible
Solution :
```bash
# Vérifier le service PostgreSQL
sudo systemctl status postgresql

# Vérifier la configuration
sudo -u postgres psql -c "SELECT version();"

# Vérifier les logs
sudo tail -f /var/lib/pgsql/data/log/postgresql-*.log
```

================================================================================
CONCLUSION
================================================================================

✅ MIGRATION TERMINÉE AVEC SUCCÈS !

L'application SMT HUB est maintenant déployée sur RedHat avec :
- 🔧 Infrastructure robuste : Nginx + PM2 + PostgreSQL
- 🔐 Sécurité renforcée : Firewall + SELinux + SSL
- 📊 Base de données PostgreSQL : Performances et scalabilité
- 💾 Sauvegardes automatisées : Base de données et fichiers
- 📈 Monitoring complet : Logs + Alertes + Métriques
- 🛠️ Maintenance automatisée : Scripts et tâches cron

L'application est prête pour la production ! 🚀

================================================================================ 